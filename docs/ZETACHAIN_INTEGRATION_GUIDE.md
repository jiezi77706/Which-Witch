# ZetaChain è·¨é“¾æ”¯ä»˜æ¥å…¥æŒ‡å—

## ğŸ“‹ ç›®å½•

1. [æ¦‚è¿°](#æ¦‚è¿°)
2. [æ¶æ„è®¾è®¡](#æ¶æ„è®¾è®¡)
3. [å‰ç½®å‡†å¤‡](#å‰ç½®å‡†å¤‡)
4. [åˆçº¦éƒ¨ç½²](#åˆçº¦éƒ¨ç½²)
5. [å‰ç«¯é›†æˆ](#å‰ç«¯é›†æˆ)
6. [æµ‹è¯•æµç¨‹](#æµ‹è¯•æµç¨‹)
7. [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)

---

## æ¦‚è¿°

### ä»€ä¹ˆæ˜¯ ZetaChainï¼Ÿ

ZetaChain æ˜¯ä¸€ä¸ªå…¨é“¾äº’æ“ä½œæ€§åŒºå—é“¾ï¼Œå…è®¸ç”¨æˆ·ä»ä»»ä½•é“¾ï¼ˆåŒ…æ‹¬æ¯”ç‰¹å¸ï¼‰å‘ä»»ä½•å…¶ä»–é“¾å‘é€æ¶ˆæ¯å’Œä»·å€¼ã€‚å®ƒé€šè¿‡ **ZRC-20** æ ‡å‡†å®ç°è·¨é“¾èµ„äº§è½¬ç§»ã€‚

### ä¸ºä»€ä¹ˆä½¿ç”¨ ZetaChainï¼Ÿ

- âœ… **çœŸæ­£çš„è·¨é“¾æ”¯ä»˜**ï¼šç”¨æˆ·å¯ä»¥ä» Ethereumã€BSCã€Polygon ç­‰ä»»æ„é“¾æ”¯ä»˜
- âœ… **ç»Ÿä¸€çš„ç”¨æˆ·ä½“éªŒ**ï¼šæ— éœ€åˆ‡æ¢ç½‘ç»œæˆ–æ¡¥æ¥èµ„äº§
- âœ… **é™ä½æ‘©æ“¦**ï¼šç”¨æˆ·ä½¿ç”¨è‡ªå·±é“¾ä¸Šçš„åŸç”Ÿä»£å¸å³å¯æ”¯ä»˜
- âœ… **æ‰©å±•æ€§å¼º**ï¼šæ”¯æŒ Bitcoinã€Ethereumã€BSCã€Polygon ç­‰å¤šæ¡é“¾

### WhichWitch çš„è·¨é“¾æ”¯ä»˜åœºæ™¯

1. **è·¨é“¾æ‰“èµ**ï¼šç”¨æˆ·åœ¨ Polygon ä¸Šç”¨ MATIC ç»™ Ethereum ä¸Šçš„åˆ›ä½œè€…æ‰“èµ
2. **è·¨é“¾æˆæƒè´¹**ï¼šç”¨æˆ·åœ¨ BSC ä¸Šç”¨ BNB æ”¯ä»˜æˆæƒè´¹åˆ° Sepolia æµ‹è¯•ç½‘
3. **è·¨é“¾ NFT è´­ä¹°**ï¼šç”¨æˆ·åœ¨ä»»æ„é“¾ä¸Šè´­ä¹° NFTï¼Œæ”¶ç›Šè‡ªåŠ¨åˆ†é…åˆ°åˆ›ä½œè€…é“¾

---

## æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ç”¨æˆ·ç•Œé¢ (Next.js)                    â”‚
â”‚  - é€‰æ‹©æ”¯ä»˜é“¾å’Œä»£å¸                                          â”‚
â”‚  - å‘èµ·è·¨é“¾æ”¯ä»˜                                              â”‚
â”‚  - æŸ¥çœ‹æ”¯ä»˜çŠ¶æ€                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æºé“¾ (Ethereum/BSC/Polygon)               â”‚
â”‚  - ç”¨æˆ·å‘èµ·æ”¯ä»˜äº¤æ˜“                                          â”‚
â”‚  - ä»£å¸è¢«é”å®š/é”€æ¯                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ZetaChain (ä¸­ç»§å±‚)                        â”‚
â”‚  ZetaCrossChainPayment åˆçº¦                                  â”‚
â”‚  - æ¥æ”¶è·¨é“¾æ¶ˆæ¯                                              â”‚
â”‚  - å¤„ç†æ”¯ä»˜é€»è¾‘                                              â”‚
â”‚  - è®¡ç®—å¹³å°è´¹ç”¨                                              â”‚
â”‚  - å‘é€åˆ°ç›®æ ‡é“¾                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç›®æ ‡é“¾ (Sepolia)                          â”‚
â”‚  PaymentManager / NFTMarketplace                             â”‚
â”‚  - æ¥æ”¶æ”¯ä»˜                                                  â”‚
â”‚  - åˆ†é…æ”¶ç›Šç»™åˆ›ä½œè€…é“¾                                        â”‚
â”‚  - æ›´æ–°é“¾ä¸ŠçŠ¶æ€                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ”¯ä»˜æµç¨‹

#### æ–¹å¼ä¸€ï¼šä½¿ç”¨ ZRC-20 ä»£å¸ï¼ˆæ¨èï¼‰

```
1. ç”¨æˆ·åœ¨æºé“¾æˆæƒ ZRC-20 ä»£å¸
2. è°ƒç”¨ ZetaCrossChainPayment.initiateCrossChainTip()
3. ZRC-20 ä»£å¸è½¬ç§»åˆ° ZetaChain
4. ZetaChain å¤„ç†æ”¯ä»˜é€»è¾‘
5. ä½¿ç”¨ ZRC-20.withdraw() å‘é€åˆ°ç›®æ ‡é“¾
6. ç›®æ ‡é“¾æ¥æ”¶åŸç”Ÿä»£å¸
```

#### æ–¹å¼äºŒï¼šä½¿ç”¨åŸç”Ÿ ZETA ä»£å¸

```
1. ç”¨æˆ·åœ¨ ZetaChain ä¸ŠæŒæœ‰ ZETA
2. è°ƒç”¨ ZetaCrossChainPayment.initiateCrossChainTipZeta()
3. ä½¿ç”¨ ZetaConnector å‘é€è·¨é“¾æ¶ˆæ¯
4. ç›®æ ‡é“¾æ¥æ”¶ ZETA æˆ–ç­‰å€¼ä»£å¸
```

---

## å‰ç½®å‡†å¤‡

### 1. å®‰è£…å¼€å‘å·¥å…·

```bash
# å®‰è£… Foundry (Solidity å¼€å‘å·¥å…·)
curl -L https://foundry.paradigm.xyz | bash
foundryup

# éªŒè¯å®‰è£…
forge --version
cast --version
```

### 2. è·å–æµ‹è¯•èµ„é‡‘

è®¿é—®ä»¥ä¸‹æ°´é¾™å¤´è·å–æµ‹è¯•ä»£å¸ï¼š

- **ZetaChain Athens æµ‹è¯•ç½‘**: https://labs.zetachain.com/get-zeta
- **Sepolia æµ‹è¯•ç½‘**: https://sepoliafaucet.com/
- **Polygon Mumbai**: https://faucet.polygon.technology/

### 3. é…ç½®ç¯å¢ƒå˜é‡

åœ¨é¡¹ç›®æ ¹ç›®å½•åˆ›å»º `.env.local`ï¼š

```bash
# ZetaChain é…ç½®
NEXT_PUBLIC_ZETA_CHAIN_ID=7001
NEXT_PUBLIC_ZETA_RPC_URL=https://zetachain-athens-evm.blockpi.network/v1/rpc/public
NEXT_PUBLIC_ZETA_PAYMENT_CONTRACT=0xä½ çš„ZetaChainåˆçº¦åœ°å€

# æ”¯æŒçš„æºé“¾
NEXT_PUBLIC_ETHEREUM_CHAIN_ID=1
NEXT_PUBLIC_BSC_CHAIN_ID=56
NEXT_PUBLIC_POLYGON_CHAIN_ID=137
NEXT_PUBLIC_SEPOLIA_CHAIN_ID=11155111

# ç›®æ ‡é“¾åˆçº¦åœ°å€
NEXT_PUBLIC_PAYMENT_MANAGER_ADDRESS=0xä½ çš„PaymentManageråœ°å€
NEXT_PUBLIC_NFT_MARKETPLACE_ADDRESS=0xä½ çš„NFTMarketplaceåœ°å€

# Alchemy API Keys (ç”¨äºå¤šé“¾æ”¯æŒ)
NEXT_PUBLIC_ALCHEMY_ETHEREUM_KEY=your_ethereum_key
NEXT_PUBLIC_ALCHEMY_POLYGON_KEY=your_polygon_key
NEXT_PUBLIC_ALCHEMY_SEPOLIA_KEY=your_sepolia_key
```

### 4. äº†è§£ ZRC-20 ä»£å¸åœ°å€

ZetaChain Athens æµ‹è¯•ç½‘çš„ ZRC-20 ä»£å¸åœ°å€ï¼š

| é“¾ | ZRC-20 åœ°å€ | ç¬¦å· |
|---|---|---|
| Ethereum | `0x91d18e54DAf4F677cB28167158d6dd21F6aB3921` | ETH.ETH |
| BSC | `0x48f80608B672DC30DC7e3dbBd0343c5F02C738Eb` | BNB.BSC |
| Polygon | `0x91d18e54DAf4F677cB28167158d6dd21F6aB3921` | MATIC.MATIC |
| Bitcoin | `0x13A0c5930C028511Dc02665E7285134B6d11A5f4` | BTC.BTC |

---

## åˆçº¦éƒ¨ç½²

### æ­¥éª¤ 1: éƒ¨ç½² ZetaChain åˆçº¦

```bash
cd src/contracts

# ç¼–è¯‘åˆçº¦
forge build

# éƒ¨ç½²åˆ° ZetaChain Athens æµ‹è¯•ç½‘
forge script script/DeployZetaPayment.s.sol:DeployZetaPayment \
  --rpc-url https://zetachain-athens-evm.blockpi.network/v1/rpc/public \
  --private-key $PRIVATE_KEY \
  --broadcast \
  --verify
```

éƒ¨ç½²æˆåŠŸåï¼Œè®°å½•åˆçº¦åœ°å€ï¼š

```
ZetaCrossChainPayment deployed at: 0x1234567890...
```

### æ­¥éª¤ 2: é…ç½®åˆçº¦

```bash
# è®¾ç½®ç¯å¢ƒå˜é‡
export ZETA_PAYMENT_ADDRESS=0xä½ çš„åˆçº¦åœ°å€

# è¿è¡Œé…ç½®è„šæœ¬
forge script script/ConfigureZetaPayment.s.sol:ConfigureZetaPayment \
  --rpc-url https://zetachain-athens-evm.blockpi.network/v1/rpc/public \
  --private-key $PRIVATE_KEY \
  --broadcast
```

é…ç½®å†…å®¹åŒ…æ‹¬ï¼š
- âœ… æ”¯æŒçš„é“¾ï¼ˆEthereum, BSC, Polygon, Sepoliaï¼‰
- âœ… æ”¯æŒçš„å¸ç§ï¼ˆETH, BNB, MATIC, BTC, USDCï¼‰
- âœ… æˆæƒçš„ä¸­ç»§å™¨åœ°å€
- âœ… ç›®æ ‡é“¾åˆçº¦åœ°å€

### æ­¥éª¤ 3: éªŒè¯éƒ¨ç½²

```bash
# æ£€æŸ¥åˆçº¦ owner
cast call $ZETA_PAYMENT_ADDRESS "owner()" \
  --rpc-url https://zetachain-athens-evm.blockpi.network/v1/rpc/public

# æ£€æŸ¥æ”¯æŒçš„é“¾
cast call $ZETA_PAYMENT_ADDRESS "supportedChains(uint256)" 11155111 \
  --rpc-url https://zetachain-athens-evm.blockpi.network/v1/rpc/public

# æ£€æŸ¥å¹³å°è´¹ç‡
cast call $ZETA_PAYMENT_ADDRESS "platformFeeRate()" \
  --rpc-url https://zetachain-athens-evm.blockpi.network/v1/rpc/public
```

---

## å‰ç«¯é›†æˆ

### æ­¥éª¤ 1: å®‰è£…ä¾èµ–

é¡¹ç›®å·²åŒ…å«å¿…è¦çš„ä¾èµ–ï¼š
- `wagmi` - Web3 React Hooks
- `viem` - TypeScript Ethereum åº“
- `@tanstack/react-query` - æ•°æ®è·å–

### æ­¥éª¤ 2: é…ç½® Wagmi

åˆ›å»º `lib/web3/config/zetachain.ts`ï¼š

```typescript
import { defineChain } from 'viem'

export const zetachainAthens = defineChain({
  id: 7001,
  name: 'ZetaChain Athens Testnet',
  network: 'zetachain-athens',
  nativeCurrency: {
    decimals: 18,
    name: 'ZETA',
    symbol: 'ZETA',
  },
  rpcUrls: {
    default: {
      http: ['https://zetachain-athens-evm.blockpi.network/v1/rpc/public'],
    },
    public: {
      http: ['https://zetachain-athens-evm.blockpi.network/v1/rpc/public'],
    },
  },
  blockExplorers: {
    default: {
      name: 'ZetaScan',
      url: 'https://zetachain-athens-3.blockscout.com',
    },
  },
  testnet: true,
})
```

æ›´æ–° `lib/web3/config.ts` æ·»åŠ  ZetaChainï¼š

```typescript
import { createConfig, http } from 'wagmi'
import { sepolia, mainnet, polygon, bsc } from 'wagmi/chains'
import { zetachainAthens } from './config/zetachain'

export const config = createConfig({
  chains: [sepolia, mainnet, polygon, bsc, zetachainAthens],
  transports: {
    [sepolia.id]: http(),
    [mainnet.id]: http(),
    [polygon.id]: http(),
    [bsc.id]: http(),
    [zetachainAthens.id]: http(),
  },
})
```

### æ­¥éª¤ 3: åˆ›å»ºè·¨é“¾æ”¯ä»˜æœåŠ¡

åˆ›å»º `lib/web3/services/cross-chain-payment.service.ts`ï¼š
```typescript
import { Address, parseEther, formatEther } from 'viem'
import { writeContract, readContract, waitForTransactionReceipt } from 'wagmi/actions'
import { config } from '../config'

// ZetaChain åˆçº¦ ABI (ç®€åŒ–ç‰ˆ)
const ZETA_PAYMENT_ABI = [
  {
    "inputs": [
      {"name": "recipient", "type": "address"},
      {"name": "workId", "type": "uint256"},
      {"name": "targetChainId", "type": "uint256"},
      {"name": "zrc20Token", "type": "address"},
      {"name": "amount", "type": "uint256"}
    ],
    "name": "initiateCrossChainTip",
    "outputs": [{"name": "paymentId", "type": "uint256"}],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {"name": "recipient", "type": "address"},
      {"name": "workId", "type": "uint256"},
      {"name": "targetChainId", "type": "uint256"}
    ],
    "name": "initiateCrossChainTipZeta",
    "outputs": [{"name": "paymentId", "type": "uint256"}],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [{"name": "paymentId", "type": "uint256"}],
    "name": "getPayment",
    "outputs": [{
      "components": [
        {"name": "paymentId", "type": "uint256"},
        {"name": "sender", "type": "address"},
        {"name": "recipient", "type": "address"},
        {"name": "amount", "type": "uint256"},
        {"name": "paymentType", "type": "uint8"},
        {"name": "workId", "type": "uint256"},
        {"name": "sourceChainId", "type": "uint256"},
        {"name": "targetChainId", "type": "uint256"},
        {"name": "sourceCurrency", "type": "string"},
        {"name": "completed", "type": "bool"},
        {"name": "timestamp", "type": "uint256"}
      ],
      "name": "",
      "type": "tuple"
    }],
    "stateMutability": "view",
    "type": "function"
  }
] as const

// ZRC-20 ä»£å¸ ABI
const ZRC20_ABI = [
  {
    "inputs": [{"name": "spender", "type": "address"}, {"name": "amount", "type": "uint256"}],
    "name": "approve",
    "outputs": [{"name": "", "type": "bool"}],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{"name": "owner", "type": "address"}, {"name": "spender", "type": "address"}],
    "name": "allowance",
    "outputs": [{"name": "", "type": "uint256"}],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{"name": "account", "type": "address"}],
    "name": "balanceOf",
    "outputs": [{"name": "", "type": "uint256"}],
    "stateMutability": "view",
    "type": "function"
  }
] as const

// æ”¯æŒçš„é“¾å’Œä»£å¸é…ç½®
export const SUPPORTED_CHAINS = {
  1: { name: 'Ethereum', symbol: 'ETH', zrc20: '0x91d18e54DAf4F677cB28167158d6dd21F6aB3921' },
  56: { name: 'BSC', symbol: 'BNB', zrc20: '0x48f80608B672DC30DC7e3dbBd0343c5F02C738Eb' },
  137: { name: 'Polygon', symbol: 'MATIC', zrc20: '0x91d18e54DAf4F677cB28167158d6dd21F6aB3921' },
  11155111: { name: 'Sepolia', symbol: 'ETH', zrc20: '0x91d18e54DAf4F677cB28167158d6dd21F6aB3921' }
}

export const ZETA_CHAIN_ID = 7001
export const ZETA_PAYMENT_CONTRACT = process.env.NEXT_PUBLIC_ZETA_PAYMENT_CONTRACT as Address

export interface CrossChainPaymentParams {
  recipient: Address
  workId: bigint
  targetChainId: number
  amount: string // ETH amount as string
  paymentType: 'tip' | 'license' | 'nft'
}

export interface PaymentStatus {
  paymentId: bigint
  sender: Address
  recipient: Address
  amount: bigint
  paymentType: number
  workId: bigint
  sourceChainId: bigint
  targetChainId: bigint
  sourceCurrency: string
  completed: boolean
  timestamp: bigint
}

export class CrossChainPaymentService {
  
  /**
   * å‘èµ·è·¨é“¾æ”¯ä»˜ (ä½¿ç”¨ ZRC-20 ä»£å¸)
   */
  static async initiateCrossChainPayment(params: CrossChainPaymentParams): Promise<bigint> {
    const { recipient, workId, targetChainId, amount, paymentType } = params
    
    const chainConfig = SUPPORTED_CHAINS[targetChainId as keyof typeof SUPPORTED_CHAINS]
    if (!chainConfig) {
      throw new Error(`Unsupported target chain: ${targetChainId}`)
    }

    const amountWei = parseEther(amount)
    const zrc20Token = chainConfig.zrc20 as Address

    // 1. æ£€æŸ¥å¹¶æˆæƒ ZRC-20 ä»£å¸
    await this.approveZRC20(zrc20Token, amountWei)

    // 2. è°ƒç”¨ç›¸åº”çš„æ”¯ä»˜æ–¹æ³•
    let functionName: string
    switch (paymentType) {
      case 'tip':
        functionName = 'initiateCrossChainTip'
        break
      case 'license':
        functionName = 'initiateCrossChainLicenseFee'
        break
      case 'nft':
        functionName = 'initiateCrossChainNFTPurchase'
        break
      default:
        throw new Error(`Unsupported payment type: ${paymentType}`)
    }

    const hash = await writeContract(config, {
      address: ZETA_PAYMENT_CONTRACT,
      abi: ZETA_PAYMENT_ABI,
      functionName,
      args: [recipient, workId, BigInt(targetChainId), zrc20Token, amountWei],
      chainId: ZETA_CHAIN_ID,
    })

    // 3. ç­‰å¾…äº¤æ˜“ç¡®è®¤
    const receipt = await waitForTransactionReceipt(config, { hash })
    
    // 4. ä»äº‹ä»¶æ—¥å¿—ä¸­æå– paymentId
    const paymentId = this.extractPaymentIdFromReceipt(receipt)
    
    return paymentId
  }

  /**
   * å‘èµ·è·¨é“¾æ”¯ä»˜ (ä½¿ç”¨åŸç”Ÿ ZETA)
   */
  static async initiateCrossChainPaymentZeta(params: CrossChainPaymentParams): Promise<bigint> {
    const { recipient, workId, targetChainId, amount, paymentType } = params
    
    const amountWei = parseEther(amount)

    // è°ƒç”¨ç›¸åº”çš„ ZETA æ”¯ä»˜æ–¹æ³•
    let functionName: string
    switch (paymentType) {
      case 'tip':
        functionName = 'initiateCrossChainTipZeta'
        break
      case 'license':
        functionName = 'initiateCrossChainLicenseFeeZeta'
        break
      case 'nft':
        functionName = 'initiateCrossChainNFTPurchaseZeta'
        break
      default:
        throw new Error(`Unsupported payment type: ${paymentType}`)
    }

    const hash = await writeContract(config, {
      address: ZETA_PAYMENT_CONTRACT,
      abi: ZETA_PAYMENT_ABI,
      functionName,
      args: [recipient, workId, BigInt(targetChainId)],
      value: amountWei,
      chainId: ZETA_CHAIN_ID,
    })

    const receipt = await waitForTransactionReceipt(config, { hash })
    const paymentId = this.extractPaymentIdFromReceipt(receipt)
    
    return paymentId
  }

  /**
   * æˆæƒ ZRC-20 ä»£å¸
   */
  private static async approveZRC20(zrc20Token: Address, amount: bigint): Promise<void> {
    // æ£€æŸ¥å½“å‰æˆæƒé¢åº¦
    const currentAllowance = await readContract(config, {
      address: zrc20Token,
      abi: ZRC20_ABI,
      functionName: 'allowance',
      args: [config.state.current?.address as Address, ZETA_PAYMENT_CONTRACT],
      chainId: ZETA_CHAIN_ID,
    }) as bigint

    // å¦‚æœæˆæƒé¢åº¦ä¸è¶³ï¼Œè¿›è¡Œæˆæƒ
    if (currentAllowance < amount) {
      const hash = await writeContract(config, {
        address: zrc20Token,
        abi: ZRC20_ABI,
        functionName: 'approve',
        args: [ZETA_PAYMENT_CONTRACT, amount],
        chainId: ZETA_CHAIN_ID,
      })

      await waitForTransactionReceipt(config, { hash })
    }
  }

  /**
   * æŸ¥è¯¢æ”¯ä»˜çŠ¶æ€
   */
  static async getPaymentStatus(paymentId: bigint): Promise<PaymentStatus> {
    const payment = await readContract(config, {
      address: ZETA_PAYMENT_CONTRACT,
      abi: ZETA_PAYMENT_ABI,
      functionName: 'getPayment',
      args: [paymentId],
      chainId: ZETA_CHAIN_ID,
    }) as any

    return {
      paymentId: payment.paymentId,
      sender: payment.sender,
      recipient: payment.recipient,
      amount: payment.amount,
      paymentType: payment.paymentType,
      workId: payment.workId,
      sourceChainId: payment.sourceChainId,
      targetChainId: payment.targetChainId,
      sourceCurrency: payment.sourceCurrency,
      completed: payment.completed,
      timestamp: payment.timestamp,
    }
  }

  /**
   * è·å– ZRC-20 ä»£å¸ä½™é¢
   */
  static async getZRC20Balance(userAddress: Address, chainId: number): Promise<string> {
    const chainConfig = SUPPORTED_CHAINS[chainId as keyof typeof SUPPORTED_CHAINS]
    if (!chainConfig) {
      throw new Error(`Unsupported chain: ${chainId}`)
    }

    const balance = await readContract(config, {
      address: chainConfig.zrc20 as Address,
      abi: ZRC20_ABI,
      functionName: 'balanceOf',
      args: [userAddress],
      chainId: ZETA_CHAIN_ID,
    }) as bigint

    return formatEther(balance)
  }

  /**
   * ä»äº¤æ˜“å›æ‰§ä¸­æå– paymentId
   */
  private static extractPaymentIdFromReceipt(receipt: any): bigint {
    // æŸ¥æ‰¾ CrossChainPaymentInitiated äº‹ä»¶
    const event = receipt.logs.find((log: any) => 
      log.topics[0] === '0x...' // CrossChainPaymentInitiated äº‹ä»¶çš„ topic hash
    )
    
    if (!event) {
      throw new Error('Payment ID not found in transaction receipt')
    }

    // è§£æ paymentId (é€šå¸¸æ˜¯ç¬¬ä¸€ä¸ª indexed å‚æ•°)
    return BigInt(event.topics[1])
  }

  /**
   * ä¼°ç®—è·¨é“¾æ”¯ä»˜è´¹ç”¨
   */
  static async estimateCrossChainFee(
    targetChainId: number,
    amount: string
  ): Promise<{ platformFee: string; gasFee: string; total: string }> {
    const amountWei = parseEther(amount)
    
    // å¹³å°è´¹ç”¨ 2.5%
    const platformFeeWei = (amountWei * BigInt(250)) / BigInt(10000)
    
    // Gas è´¹ç”¨ä¼°ç®— (ç®€åŒ–ç‰ˆï¼Œå®é™…åº”è¯¥è°ƒç”¨åˆçº¦æ–¹æ³•)
    const gasFeeWei = parseEther('0.001') // çº¦ $2-3 USD
    
    const totalWei = amountWei + platformFeeWei + gasFeeWei

    return {
      platformFee: formatEther(platformFeeWei),
      gasFee: formatEther(gasFeeWei),
      total: formatEther(totalWei)
    }
  }
}
```

### æ­¥éª¤ 4: åˆ›å»ºè·¨é“¾æ”¯ä»˜ç»„ä»¶

åˆ›å»º `components/whichwitch/cross-chain-payment-modal.tsx`ï¼š

```tsx
'use client'

import { useState, useEffect } from 'react'
import { useAccount, useChainId, useSwitchChain } from 'wagmi'
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Badge } from '@/components/ui/badge'
import { Loader2, ArrowRight, CheckCircle, AlertCircle } from 'lucide-react'
import { toast } from 'sonner'
import { CrossChainPaymentService, SUPPORTED_CHAINS, ZETA_CHAIN_ID } from '@/lib/web3/services/cross-chain-payment.service'

interface CrossChainPaymentModalProps {
  isOpen: boolean
  onClose: () => void
  recipient: string
  workId: number
  paymentType: 'tip' | 'license' | 'nft'
  title: string
}

export function CrossChainPaymentModal({
  isOpen,
  onClose,
  recipient,
  workId,
  paymentType,
  title
}: CrossChainPaymentModalProps) {
  const { address } = useAccount()
  const chainId = useChainId()
  const { switchChain } = useSwitchChain()

  const [amount, setAmount] = useState('')
  const [targetChainId, setTargetChainId] = useState<number>(11155111) // é»˜è®¤ Sepolia
  const [paymentMethod, setPaymentMethod] = useState<'zrc20' | 'zeta'>('zrc20')
  const [isLoading, setIsLoading] = useState(false)
  const [paymentId, setPaymentId] = useState<bigint | null>(null)
  const [paymentStatus, setPaymentStatus] = useState<'pending' | 'completed' | 'failed'>('pending')

  // è´¹ç”¨ä¼°ç®—
  const [fees, setFees] = useState<{
    platformFee: string
    gasFee: string
    total: string
  } | null>(null)

  // ä¼°ç®—è´¹ç”¨
  useEffect(() => {
    if (amount && parseFloat(amount) > 0) {
      CrossChainPaymentService.estimateCrossChainFee(targetChainId, amount)
        .then(setFees)
        .catch(console.error)
    } else {
      setFees(null)
    }
  }, [amount, targetChainId])

  // æ£€æŸ¥æ”¯ä»˜çŠ¶æ€
  useEffect(() => {
    if (paymentId) {
      const checkStatus = async () => {
        try {
          const status = await CrossChainPaymentService.getPaymentStatus(paymentId)
          setPaymentStatus(status.completed ? 'completed' : 'pending')
        } catch (error) {
          console.error('Failed to check payment status:', error)
          setPaymentStatus('failed')
        }
      }

      const interval = setInterval(checkStatus, 5000) // æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡
      return () => clearInterval(interval)
    }
  }, [paymentId])

  const handlePayment = async () => {
    if (!address || !amount || parseFloat(amount) <= 0) {
      toast.error('è¯·å¡«å†™æœ‰æ•ˆçš„æ”¯ä»˜é‡‘é¢')
      return
    }

    // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ‡æ¢åˆ° ZetaChain
    if (chainId !== ZETA_CHAIN_ID) {
      try {
        await switchChain({ chainId: ZETA_CHAIN_ID })
      } catch (error) {
        toast.error('è¯·åˆ‡æ¢åˆ° ZetaChain ç½‘ç»œ')
        return
      }
    }

    setIsLoading(true)

    try {
      let resultPaymentId: bigint

      if (paymentMethod === 'zrc20') {
        resultPaymentId = await CrossChainPaymentService.initiateCrossChainPayment({
          recipient: recipient as `0x${string}`,
          workId: BigInt(workId),
          targetChainId,
          amount,
          paymentType
        })
      } else {
        resultPaymentId = await CrossChainPaymentService.initiateCrossChainPaymentZeta({
          recipient: recipient as `0x${string}`,
          workId: BigInt(workId),
          targetChainId,
          amount,
          paymentType
        })
      }

      setPaymentId(resultPaymentId)
      toast.success('è·¨é“¾æ”¯ä»˜å·²å‘èµ·ï¼Œæ­£åœ¨å¤„ç†ä¸­...')
      
    } catch (error: any) {
      console.error('Payment failed:', error)
      toast.error(error.message || 'æ”¯ä»˜å¤±è´¥ï¼Œè¯·é‡è¯•')
      setPaymentStatus('failed')
    } finally {
      setIsLoading(false)
    }
  }

  const getStatusIcon = () => {
    switch (paymentStatus) {
      case 'pending':
        return <Loader2 className="h-4 w-4 animate-spin" />
      case 'completed':
        return <CheckCircle className="h-4 w-4 text-green-500" />
      case 'failed':
        return <AlertCircle className="h-4 w-4 text-red-500" />
    }
  }

  const getStatusText = () => {
    switch (paymentStatus) {
      case 'pending':
        return 'å¤„ç†ä¸­...'
      case 'completed':
        return 'æ”¯ä»˜å®Œæˆ'
      case 'failed':
        return 'æ”¯ä»˜å¤±è´¥'
    }
  }

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>{title}</DialogTitle>
        </DialogHeader>

        <div className="space-y-4">
          {/* æ”¯ä»˜ä¿¡æ¯ */}
          <div className="bg-gray-50 p-4 rounded-lg">
            <div className="flex justify-between text-sm">
              <span>æ¥æ”¶è€…:</span>
              <span className="font-mono">{recipient.slice(0, 6)}...{recipient.slice(-4)}</span>
            </div>
            <div className="flex justify-between text-sm">
              <span>ä½œå“ID:</span>
              <span>{workId}</span>
            </div>
          </div>

          {/* æ”¯ä»˜æ–¹å¼é€‰æ‹© */}
          <div>
            <label className="text-sm font-medium">æ”¯ä»˜æ–¹å¼</label>
            <Select value={paymentMethod} onValueChange={(value: 'zrc20' | 'zeta') => setPaymentMethod(value)}>
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="zrc20">ä½¿ç”¨ ZRC-20 ä»£å¸ (æ¨è)</SelectItem>
                <SelectItem value="zeta">ä½¿ç”¨åŸç”Ÿ ZETA</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {/* ç›®æ ‡é“¾é€‰æ‹© */}
          <div>
            <label className="text-sm font-medium">ç›®æ ‡é“¾</label>
            <Select value={targetChainId.toString()} onValueChange={(value) => setTargetChainId(parseInt(value))}>
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {Object.entries(SUPPORTED_CHAINS).map(([chainId, config]) => (
                  <SelectItem key={chainId} value={chainId}>
                    {config.name} ({config.symbol})
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          {/* æ”¯ä»˜é‡‘é¢ */}
          <div>
            <label className="text-sm font-medium">æ”¯ä»˜é‡‘é¢</label>
            <div className="flex items-center space-x-2">
              <Input
                type="number"
                step="0.001"
                placeholder="0.0"
                value={amount}
                onChange={(e) => setAmount(e.target.value)}
                disabled={isLoading || paymentId !== null}
              />
              <Badge variant="secondary">
                {paymentMethod === 'zrc20' 
                  ? SUPPORTED_CHAINS[targetChainId as keyof typeof SUPPORTED_CHAINS]?.symbol 
                  : 'ZETA'
                }
              </Badge>
            </div>
          </div>

          {/* è´¹ç”¨æ˜ç»† */}
          {fees && (
            <div className="bg-blue-50 p-3 rounded-lg text-sm">
              <div className="flex justify-between">
                <span>æ”¯ä»˜é‡‘é¢:</span>
                <span>{amount} {paymentMethod === 'zrc20' 
                  ? SUPPORTED_CHAINS[targetChainId as keyof typeof SUPPORTED_CHAINS]?.symbol 
                  : 'ZETA'}</span>
              </div>
              <div className="flex justify-between">
                <span>å¹³å°è´¹ç”¨ (2.5%):</span>
                <span>{fees.platformFee}</span>
              </div>
              <div className="flex justify-between">
                <span>è·¨é“¾ Gas è´¹:</span>
                <span>{fees.gasFee}</span>
              </div>
              <div className="flex justify-between font-medium border-t pt-1 mt-1">
                <span>æ€»è®¡:</span>
                <span>{fees.total}</span>
              </div>
            </div>
          )}

          {/* æ”¯ä»˜çŠ¶æ€ */}
          {paymentId && (
            <div className="bg-gray-50 p-4 rounded-lg">
              <div className="flex items-center space-x-2">
                {getStatusIcon()}
                <span className="text-sm font-medium">{getStatusText()}</span>
              </div>
              <div className="text-xs text-gray-500 mt-1">
                æ”¯ä»˜ID: {paymentId.toString()}
              </div>
            </div>
          )}

          {/* æ“ä½œæŒ‰é’® */}
          <div className="flex space-x-2">
            <Button variant="outline" onClick={onClose} disabled={isLoading}>
              å–æ¶ˆ
            </Button>
            <Button 
              onClick={handlePayment} 
              disabled={isLoading || !amount || parseFloat(amount) <= 0 || paymentStatus === 'completed'}
              className="flex-1"
            >
              {isLoading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  å¤„ç†ä¸­...
                </>
              ) : paymentStatus === 'completed' ? (
                <>
                  <CheckCircle className="mr-2 h-4 w-4" />
                  æ”¯ä»˜å®Œæˆ
                </>
              ) : (
                <>
                  å‘èµ·è·¨é“¾æ”¯ä»˜
                  <ArrowRight className="ml-2 h-4 w-4" />
                </>
              )}
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  )
}
```

### æ­¥éª¤ 5: é›†æˆåˆ°ç°æœ‰ç»„ä»¶

æ›´æ–° `components/whichwitch/work-card.tsx` æ·»åŠ è·¨é“¾æ”¯ä»˜æŒ‰é’®ï¼š

```tsx
// åœ¨ç°æœ‰çš„ work-card.tsx ä¸­æ·»åŠ 
import { CrossChainPaymentModal } from './cross-chain-payment-modal'

// åœ¨ç»„ä»¶ä¸­æ·»åŠ çŠ¶æ€
const [showCrossChainPayment, setShowCrossChainPayment] = useState(false)

// åœ¨æ¸²æŸ“ä¸­æ·»åŠ æŒ‰é’®å’Œæ¨¡æ€æ¡†
<Button 
  variant="outline" 
  size="sm"
  onClick={() => setShowCrossChainPayment(true)}
>
  è·¨é“¾æ‰“èµ
</Button>

<CrossChainPaymentModal
  isOpen={showCrossChainPayment}
  onClose={() => setShowCrossChainPayment(false)}
  recipient={work.creator}
  workId={work.id}
  paymentType="tip"
  title="è·¨é“¾æ‰“èµ"
/>
```

---

## æµ‹è¯•æµç¨‹

### 1. æœ¬åœ°æµ‹è¯•

```bash
# å¯åŠ¨å¼€å‘æœåŠ¡å™¨
npm run dev

# åœ¨æµè§ˆå™¨ä¸­è®¿é—®
open http://localhost:3000
```

### 2. åˆçº¦æµ‹è¯•

```bash
cd src/contracts

# è¿è¡Œå•å…ƒæµ‹è¯•
forge test

# è¿è¡Œç‰¹å®šæµ‹è¯•
forge test --match-test testCrossChainTip

# æŸ¥çœ‹æµ‹è¯•è¦†ç›–ç‡
forge coverage
```

### 3. é›†æˆæµ‹è¯•æµç¨‹

1. **å‡†å¤‡æµ‹è¯•ç¯å¢ƒ**
   - åœ¨ MetaMask ä¸­æ·»åŠ  ZetaChain Athens æµ‹è¯•ç½‘
   - è·å–æµ‹è¯• ZETA ä»£å¸
   - è·å– Sepolia æµ‹è¯• ETH

2. **æµ‹è¯•è·¨é“¾æ‰“èµ**
   - è¿æ¥ ZetaChain ç½‘ç»œ
   - é€‰æ‹©ç›®æ ‡é“¾ (Sepolia)
   - è¾“å…¥æ‰“èµé‡‘é¢
   - ç¡®è®¤äº¤æ˜“
   - ç­‰å¾…è·¨é“¾å¤„ç†å®Œæˆ

3. **éªŒè¯ç»“æœ**
   - æ£€æŸ¥ ZetaChain ä¸Šçš„æ”¯ä»˜è®°å½•
   - éªŒè¯ Sepolia ä¸Šçš„æ”¶ç›Šåˆ†é…
   - ç¡®è®¤åˆ›ä½œè€…é“¾æ”¶åˆ°æ”¶ç›Š

### 4. æµ‹è¯•ç”¨ä¾‹

åˆ›å»º `scripts/test-cross-chain-payment.js`ï¼š

```javascript
const { ethers } = require('ethers')

// æµ‹è¯•è·¨é“¾æ”¯ä»˜åŠŸèƒ½
async function testCrossChainPayment() {
  console.log('ğŸ§ª å¼€å§‹æµ‹è¯•è·¨é“¾æ”¯ä»˜åŠŸèƒ½...')
  
  // 1. è¿æ¥ ZetaChain
  const provider = new ethers.JsonRpcProvider(
    'https://zetachain-athens-evm.blockpi.network/v1/rpc/public'
  )
  
  // 2. æµ‹è¯•åˆçº¦è°ƒç”¨
  const contractAddress = process.env.ZETA_PAYMENT_CONTRACT
  const contract = new ethers.Contract(contractAddress, ABI, provider)
  
  // 3. æŸ¥è¯¢åˆçº¦çŠ¶æ€
  const owner = await contract.owner()
  const platformFeeRate = await contract.platformFeeRate()
  const nextPaymentId = await contract.nextPaymentId()
  
  console.log('âœ… åˆçº¦çŠ¶æ€:')
  console.log(`   Owner: ${owner}`)
  console.log(`   Platform Fee Rate: ${platformFeeRate} basis points`)
  console.log(`   Next Payment ID: ${nextPaymentId}`)
  
  // 4. æµ‹è¯•æ”¯æŒçš„é“¾
  const supportedChains = [1, 56, 137, 11155111]
  for (const chainId of supportedChains) {
    const isSupported = await contract.supportedChains(chainId)
    console.log(`   Chain ${chainId}: ${isSupported ? 'âœ…' : 'âŒ'}`)
  }
  
  console.log('ğŸ‰ æµ‹è¯•å®Œæˆ!')
}

testCrossChainPayment().catch(console.error)
```

---

## å¸¸è§é—®é¢˜

### Q1: ä¸ºä»€ä¹ˆé€‰æ‹© ZetaChain è€Œä¸æ˜¯å…¶ä»–è·¨é“¾æ–¹æ¡ˆï¼Ÿ

**A:** ZetaChain çš„ä¼˜åŠ¿ï¼š
- âœ… **åŸç”Ÿè·¨é“¾æ”¯æŒ**ï¼šæ— éœ€æ¡¥æ¥ï¼Œç›´æ¥è·¨é“¾è½¬è´¦
- âœ… **æ”¯æŒæ¯”ç‰¹å¸**ï¼šå”¯ä¸€æ”¯æŒ Bitcoin çš„å…¨é“¾å¹³å°
- âœ… **ç»Ÿä¸€æµåŠ¨æ€§**ï¼šZRC-20 æ ‡å‡†ç»Ÿä¸€æ‰€æœ‰é“¾çš„èµ„äº§
- âœ… **å¼€å‘è€…å‹å¥½**ï¼šç®€å•çš„ APIï¼Œä¸°å¯Œçš„æ–‡æ¡£

### Q2: ZRC-20 ä»£å¸å’Œæ™®é€š ERC-20 æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

**A:** ZRC-20 æ˜¯ ZetaChain çš„è·¨é“¾ä»£å¸æ ‡å‡†ï¼š
- ğŸ”„ **è·¨é“¾åŸç”Ÿ**ï¼šå¯ä»¥åœ¨ä»»æ„é“¾ä¹‹é—´è½¬ç§»
- ğŸ¦ **ç»Ÿä¸€æµåŠ¨æ€§**ï¼šæ‰€æœ‰é“¾ä¸Šçš„åŒç§èµ„äº§å…±äº«æµåŠ¨æ€§
- âš¡ **å³æ—¶ç»“ç®—**ï¼šæ— éœ€ç­‰å¾…æ¡¥æ¥ç¡®è®¤
- ğŸ›¡ï¸ **å®‰å…¨æ€§é«˜**ï¼šç”± ZetaChain éªŒè¯è€…ç½‘ç»œä¿æŠ¤

### Q3: è·¨é“¾æ”¯ä»˜çš„è´¹ç”¨ç»“æ„æ˜¯ä»€ä¹ˆï¼Ÿ

**A:** è´¹ç”¨åŒ…å«ä¸‰éƒ¨åˆ†ï¼š
1. **å¹³å°è´¹ç”¨**: 2.5% (å¯é…ç½®)
2. **ZetaChain Gas è´¹**: ~$2-5 USD
3. **ç›®æ ‡é“¾ Gas è´¹**: ç”± ZetaChain ä»£ä»˜

### Q4: è·¨é“¾æ”¯ä»˜éœ€è¦å¤šé•¿æ—¶é—´ï¼Ÿ

**A:** é€šå¸¸æƒ…å†µä¸‹ï¼š
- **ZetaChain ç¡®è®¤**: 2-5 ç§’
- **è·¨é“¾å¤„ç†**: 1-3 åˆ†é’Ÿ
- **ç›®æ ‡é“¾ç¡®è®¤**: å–å†³äºç›®æ ‡é“¾çš„å‡ºå—æ—¶é—´

### Q5: å¦‚æœè·¨é“¾æ”¯ä»˜å¤±è´¥æ€ä¹ˆåŠï¼Ÿ

**A:** ZetaChain æä¾›å¤šé‡ä¿éšœï¼š
- ğŸ”„ **è‡ªåŠ¨é‡è¯•**: å¤±è´¥æ—¶è‡ªåŠ¨é‡è¯•
- ğŸ’° **èµ„é‡‘å®‰å…¨**: å¤±è´¥æ—¶èµ„é‡‘è‡ªåŠ¨é€€å›
- ğŸ“Š **çŠ¶æ€è¿½è¸ª**: å®æ—¶æŸ¥è¯¢æ”¯ä»˜çŠ¶æ€
- ğŸ› ï¸ **æ‰‹åŠ¨å¹²é¢„**: æç«¯æƒ…å†µä¸‹å¯æ‰‹åŠ¨å¤„ç†

### Q6: å¦‚ä½•æ·»åŠ æ–°çš„æ”¯æŒé“¾ï¼Ÿ

**A:** éœ€è¦ä»¥ä¸‹æ­¥éª¤ï¼š
1. åœ¨ ZetaChain ä¸Šé…ç½®æ–°é“¾æ”¯æŒ
2. éƒ¨ç½²ç›®æ ‡é“¾æ¥æ”¶åˆçº¦
3. æ›´æ–°å‰ç«¯é…ç½®
4. æµ‹è¯•è·¨é“¾åŠŸèƒ½

### Q7: ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²æ³¨æ„äº‹é¡¹ï¼Ÿ

**A:** é‡è¦æ£€æŸ¥æ¸…å•ï¼š
- âœ… ä½¿ç”¨ ZetaChain ä¸»ç½‘åˆçº¦åœ°å€
- âœ… é…ç½®æ­£ç¡®çš„ç›®æ ‡é“¾åˆçº¦
- âœ… è®¾ç½®åˆç†çš„è´¹ç‡å’Œé™é¢
- âœ… å®æ–½ç›‘æ§å’Œå‘Šè­¦
- âœ… å‡†å¤‡åº”æ€¥å¤„ç†æ–¹æ¡ˆ

---

## æ€»ç»“

é€šè¿‡é›†æˆ ZetaChainï¼ŒWhichWitch å¹³å°å®ç°äº†çœŸæ­£çš„è·¨é“¾æ”¯ä»˜åŠŸèƒ½ï¼š

ğŸ¯ **ç”¨æˆ·ä½“éªŒæå‡**
- ç”¨æˆ·æ— éœ€åˆ‡æ¢ç½‘ç»œæˆ–æ¡¥æ¥èµ„äº§
- æ”¯æŒä»ä»»æ„é“¾å‘ä»»æ„é“¾æ”¯ä»˜
- ç»Ÿä¸€çš„æ”¯ä»˜ç•Œé¢å’Œæµç¨‹

ğŸ”§ **æŠ€æœ¯æ¶æ„ä¼˜åŒ–**
- åŸºäº ZRC-20 æ ‡å‡†çš„ç»Ÿä¸€èµ„äº§ç®¡ç†
- æ™ºèƒ½åˆçº¦è‡ªåŠ¨å¤„ç†è·¨é“¾é€»è¾‘
- å®æ—¶çŠ¶æ€è¿½è¸ªå’Œé”™è¯¯å¤„ç†

ğŸ’° **å•†ä¸šä»·å€¼å¢å¼º**
- æ‰©å¤§ç”¨æˆ·è¦†ç›–é¢ï¼ˆæ”¯æŒå¤šé“¾ç”¨æˆ·ï¼‰
- é™ä½æ”¯ä»˜æ‘©æ“¦ï¼ˆæ— éœ€æ¡¥æ¥ï¼‰
- å¢åŠ å¹³å°æ”¶å…¥ï¼ˆè·¨é“¾æ”¯ä»˜è´¹ç”¨ï¼‰

æ¥ä¸‹æ¥ä½ å¯ä»¥ï¼š
1. æŒ‰ç…§æŒ‡å—éƒ¨ç½² ZetaChain åˆçº¦
2. é›†æˆå‰ç«¯è·¨é“¾æ”¯ä»˜åŠŸèƒ½
3. è¿›è¡Œå……åˆ†çš„æµ‹è¯•
4. é€æ­¥ä¸Šçº¿åˆ°ç”Ÿäº§ç¯å¢ƒ

æœ‰ä»»ä½•é—®é¢˜éƒ½å¯ä»¥éšæ—¶è¯¢é—®ï¼